{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This repository contains a terraform module that supports teams in implementing immutable backups in Azure.</p> <p>It's aim is to give developers a consistent way of creating, configuring and monitoring immutable backups using Azure Backup Vault.</p>"},{"location":"#technology-stack","title":"Technology Stack","text":"<p>The following technologies have been used:</p> <ul> <li>Azure</li> <li>Azure CLI</li> <li>Terraform (v1.9 or later)</li> <li>MkDocs and the Squidfunk MkDocs Material UI theme</li> <li>Go (for end-to-end testing)</li> <li>Terratest</li> <li>Azure SDK for Go</li> </ul>"},{"location":"design/","title":"Design","text":""},{"location":"design/#design","title":"Design","text":""},{"location":"design/#overview","title":"Overview","text":"<p>A solution which utilises the blueprint will consist of the following types of Azure resources</p> <ul> <li>Azure backup vault and backup policies/instances</li> <li>Azure policy definitions and assignments</li> <li>Azure monitor</li> <li>Entra ID</li> <li>Tfstate storage account</li> <li>Resources that need to be backed up</li> </ul>"},{"location":"design/#architecture","title":"Architecture","text":"<p>The following diagram illustrates the high level architecture:</p> <p></p>"},{"location":"design/#description","title":"Description","text":"<ol> <li> <p>The backup vault stores the backups of a variety of different Azure resources. A number of backup instances are created in the vault, which have a policy applied that defines the configuration for a backup such as the retention period and schedule. The vault is configured as immutable and locked to enforce tamper proof backups. The backup vault resides in it's own isolated resource group (NOTE this behaviour can be overridden if the vault needs to be deployed into an externally managed resource group).</p> </li> <li> <p>Backup instances link the resources to be backed up and an associated backup policy, and one registered trigger the backup process. The resources directly supported are Azure Blob Storage, Managed Disks, PostgreSQL (single server and flexible server) and AKS instances, although other resources are supported indirectly through Azure Storage (see point 7 for more details). Backup instances are created based on the variables supplied to module, which include configuration and details of the resources that need to be backed up.</p> </li> <li> <p>The backup vault accesses resources to be backed up through a System Assigned Managed Identity - a secure way of enabling communication between defined resources without managing a secret/password, which is assigned the necessary roles to the resources that require backup.</p> </li> <li> <p>Backup administrators are a group of identities that will have time limited read only access to the backup vault in order to access and restore backups as required. The backup administrators will also be responsible for monitoring and auditing backup activity via Azure Monitor (see point 6 for more details), although this task may be delegated to service staff performing the role of backup monitors.</p> </li> <li> <p>The solution requires a user account with elevated subscription contributor permissions that can create the backup resources (such as the backup resource group and backup vault) and assign roles to the resources that require backup. This identity should be implemented as a federated credential of an app registration, which is like a passport that lets you access different services without needing to manage a separate password. The identity also needs writer access to a dedicated Storage Account in order to read and write the terraform infrastructure state. See the deployment identity section for more details.</p> </li> <li> <p>All backup telemetry will flow into Azure Monitor for monitoring and auditing purposes. This will provide access to data such as backup logs and metrics, and provide observability over the solution. Should the need arise, the telemetry could also be integrated into an external monitoring solution.</p> </li> <li> <p>Some resources such as Azure SQL and Azure Key Vault are not directly supported by Azure backup vault, but can be incorporated via a supplementary process that backs up the data to Azure Blob Storage first. In the case of Azure SQL, a typical scenario could be an Azure Logic App that takes a backup of Azure SQL on a regular basis and stores the data in Azure Blob Storage.  It is the aspiration of this solution to provide guidance and tooling that teams can adopt to support these scenarios.</p> </li> </ol>"},{"location":"design/#terraform-design","title":"Terraform Design","text":"<p>The following diagram illustrates the terraform design:</p> <p></p>"},{"location":"design/#description_1","title":"Description","text":"<ol> <li>The az-backup module is essentially everything within the <code>./infrastructure</code> directory of this repository. It consists of the following resources:</li> <li>A resource group which will contain the other resources in the module.</li> <li>A backup vault within which backup policies and instances are configured..</li> <li>A role assignment which provides read access to the vault.</li> <li> <p>A number of backup modules which can backup a specific type of resource.</p> </li> <li> <p>Backup modules are created which define policies that setup and trigger the backups once the module is deployed. The policies which are configured via terraform variables.</p> </li> <li> <p>Each backup module deploys the resources that are required to backup a resource that contains source data (e.g. a storage account). It consists of a backup policy that is configured in the backup vault on deployment and defines the rules such as backup retention and schedule, and an backup instance that applies the policy and initiates the backups of a specified resource.</p> </li> <li> <p>The consuming application is developed and maintained by the blueprint consumer. It will likely consist of a number of resource that make up an application or service, and contain resources that need to be backed up. The recommended way of using az-backup in the consuming application is to specify the blueprint repository as the remote source of a terraform module. See the following link for more information.</p> </li> <li> <p>The az-backup module is configured by terraform variables which are applied at deployment time. The consuming application can control parameters such as the vault name, location and redundancy, as well as the backup policies and their retention period and schedule. See the module variables section for more details.</p> </li> </ol>"},{"location":"developer-guide/","title":"Developer Guide","text":""},{"location":"developer-guide/#developer-guide","title":"Developer Guide","text":""},{"location":"developer-guide/#overview","title":"Overview","text":"<p>The following guide is for developers working on the blueprint solution - not for developers that are consuming the blueprint.</p>"},{"location":"developer-guide/#environment-setup","title":"Environment Setup","text":"<p>The following are pre-requisites to working with the solution:</p> <ul> <li>An Azure subscription for development purposes</li> <li>An Azure identity which has been assigned the following roles at the subscription level:<ul> <li>Contributor (to create resources)</li> <li>Role Based Access Control Administrator (to assign roles to the backup vault managed identity) with a condition limiting the roles that can be assigned to:<ul> <li>Disk Backup Reader</li> <li>Disk Snapshot Contributor</li> <li>PostgreSQL Flexible Server Long Term Retention Backup Role</li> <li>Storage Account Backup Contributor</li> <li>Reader</li> </ul> </li> </ul> </li> <li>Azure CLI installed</li> <li>Terraform installed</li> <li>Go installed (to run the end-to-end tests)</li> </ul> <p>Ensure all installed components have been added to the <code>%PATH%</code> - e.g. <code>az</code>, <code>terraform</code> and <code>go</code>.</p>"},{"location":"developer-guide/#getting-started","title":"Getting Started","text":"<p>Take the following steps to get started in configuring and verifying the infrastructure for your development environment:</p> <ol> <li> <p>Setup environment variables</p> <p>Set the following environment variables in order to connect to Azure in the following steps:</p> <pre><code>$env:ARM_TENANT_ID=\"&lt;your-tenant-id&gt;\"\n$env:ARM_SUBSCRIPTION_ID=\"&lt;your-subscription-id&gt;\"\n$env:ARM_CLIENT_ID=\"&lt;your-client-id&gt;\"\n$env:ARM_CLIENT_SECRET=\"&lt;your-client-secret&gt;\"\n</code></pre> </li> <li> <p>Create Backend</p> <p>A backend (e.g. storage account) is required in order to store the tfstate and work with Terraform.</p> <p>Run the following powershell script to create the backend with default settings: <code>./scripts/create-tf-backend.ps1</code>. This script will create a resource group called <code>rg-nhsbackup</code> containing a storage account called <code>satfstate&lt;random-id&gt;</code>.</p> <p>Make a note of the name of the storage account in the script output - it's generated with a random suffix, and you'll need it in the following steps to initialise the terraform.</p> </li> <li> <p>Initialise Terraform</p> <p>Change the working directory to <code>./infrastructure</code>.</p> <p>Terraform can now be initialised by running the following command:</p> <pre><code>terraform init -backend=true -backend-config=\"resource_group_name=rg-nhsbackup\" -backend-config=\"storage_account_name=&lt;storage-account-name&gt;\" -backend-config=\"container_name=tfstate\" -backend-config=\"key=terraform.tfstate\"\n</code></pre> </li> <li> <p>Prepare Terraform Variables</p> <p>You need to specify the mandatory terraform variables as a minimum, and may want to specify a number of the optional variables.</p> <p>You can specify the variables via the command line when executing <code>terraform apply</code>, or by preparing a tfvars file and specifying the path to that file.</p> <p>Here are examples of each approach:</p> <pre><code>terraform apply -var resource_group_name=&lt;resource-group-name&gt; -var backup_vault_name=&lt;backup-vault-name&gt; var tags={\"tagOne\" = \"tagOneValue\"} -var blob_storage_backups={\"backup1\" = { \"backup_name\" = \"myblob\", \"retention_period\" = \"P7D\", \"backup_intervals\" = [\"R/2024-01-01T00:00:00+00:00/P1D\"], \"storage_account_id\" = \"id\" }}\n</code></pre> <pre><code>terraform apply -var-file=\"&lt;your-var-file&gt;.tfvars\n</code></pre> </li> <li> <p>Apply Terraform</p> <p>Apply the Terraform code to create the infrastructure.</p> <p>The <code>-auto-approve</code> flag is used to automatically approve the plan, you can remove this flag to review the plan before applying.</p> <pre><code>terraform apply -auto-approve\n</code></pre> <p>Now review the deployed infrastructure in the Azure portal. You will find the resources deployed to a resource group called <code>rg-nhsbackup-myvault</code> (unless you specified a different vault name in the tfvars).</p> <p>Should you want to, you can remove the infrastructure with the following command:</p> <pre><code>terraform destroy -auto-approve\n</code></pre> </li> </ol>"},{"location":"developer-guide/#testing","title":"Testing","text":""},{"location":"developer-guide/#integration-tests","title":"Integration Tests","text":"<p>The test suite consists of a number Terraform HCL integration tests that use a mock azurerm provider.</p> <p>See this link for more information.</p> <p>TIP! Consider adopting the classic red-green-refactor approach using the integration test framework when adding or modifying the terraform code.</p> <p>Take the following steps to run the test suite:</p> <ol> <li> <p>Initialise Terraform</p> <p>Change the working directory to <code>./tests/integration-tests</code>.</p> <p>Terraform can now be initialised by running the following command:</p> <pre><code>terraform init -backend=false\n</code></pre> <p>NOTE: There's no need to initialise a backend for the purposes of running the tests.</p> </li> <li> <p>Run the tests</p> <p>Run the tests with the following command:</p> <pre><code>terraform test\n</code></pre> </li> </ol>"},{"location":"developer-guide/#end-to-end-tests","title":"End to End Tests","text":"<p>The end to end tests are written in go, and use the terratest library and the Azure SDK for Go.</p> <p>The tests depend on a connection to Azure so it can create an environment that the tests can be executed against - the environment is torn down once the test run has completed.</p> <p>See the following resources for docs and examples of terratest and the Azure SDK:</p> <ul> <li>Terratest docs</li> <li>Terratest repository</li> <li>Terratest test examples</li> <li>Azure SDK</li> <li>Azure SDK Data Protection Module</li> </ul> <p>To run the tests, take the following steps:</p> <ol> <li> <p>Install go packages</p> <p>You only need to do this once when setting up your environment.</p> <p>Change the working directory to <code>./tests/end-to-end-tests</code>.</p> <p>Run the following command:</p> <pre><code>go mod tidy\n</code></pre> </li> <li> <p>Setup environment variables</p> <p>The end-to-end test suite needs to login to Azure in order to execute the tests and therefore the following environment variables must be set.</p> <pre><code>$env:ARM_TENANT_ID=\"&lt;your-tenant-id&gt;\"\n$env:ARM_SUBSCRIPTION_ID=\"&lt;your-subscription-id&gt;\"\n$env:ARM_CLIENT_ID=\"&lt;your-client-id&gt;\"\n$env:ARM_CLIENT_SECRET=\"&lt;your-client-secret&gt;\"\n$env:TF_STATE_RESOURCE_GROUP=\"rg-nhsbackup\"\n$env:TF_STATE_STORAGE_ACCOUNT=\"&lt;storage-account-name&gt;\"\n$env:TF_STATE_STORAGE_CONTAINER=\"tfstate\"\n</code></pre> <p>For the storage account name, the TF state backend should have been created during the getting started guide, at which point the storage account will have been created and the name generated.</p> </li> <li> <p>Run the tests</p> <p>Run all the tests with the following command:</p> <pre><code>go test -v -timeout 10m\n</code></pre> <p>Run a single test with the following command:</p> <pre><code>go test -v -timeout 10m -run &lt;TestFunctionName&gt;\n</code></pre> </li> </ol>"},{"location":"developer-guide/#debugging","title":"Debugging","text":"<p>To debug the tests in vscode, add the following configuration to launch settings and run the configuration:</p> <pre><code>{\n    \"configurations\": [\n        {\n            \"name\": \"Go Test\",\n            \"type\": \"go\",\n            \"request\": \"launch\",\n            \"mode\": \"test\",\n            \"program\": \"${workspaceFolder}/tests/end-to-end-tests\",\n            \"env\": {\n                \"ARM_TENANT_ID\": \"&lt;your-tenant-id&gt;\",\n                \"ARM_SUBSCRIPTION_ID\": \"&lt;your-subscription-id&gt;\",\n                \"ARM_CLIENT_ID\": \"&lt;your-client-id&gt;\",\n                \"ARM_CLIENT_SECRET\": \"&lt;your-client-secret&gt;\",\n                \"TF_STATE_RESOURCE_GROUP\": \"rg-nhsbackup\",\n                \"TF_STATE_STORAGE_ACCOUNT\": \"&lt;storage-account-name&gt;\",\n                \"TF_STATE_STORAGE_CONTAINER\": \"tfstate\"\n            }\n        }       \n    ]\n}\n</code></pre> <p>For the storage account name, the TF state backend should have been created during the getting started guide, at which point the storage account will have been created and the name generated.</p>"},{"location":"developer-guide/#creating-a-release","title":"Creating a Release","text":"<p>The CI pipeline workflow uses the Semantic Release GitHub action to create semantic version number (e.g. 1.0.0 / major.minor.patch), add a tag to the repository, and publish a release to GitHub. See the <code>./releaserc</code> file at the repo root to view the configuration that has been applied.</p> <p>Semantic Release relies on commit message conventions, therefore any merge into <code>main</code> should squash merged with a commit message that adheres to the semantic release formatting rules.</p> <p>When a PR is merged into <code>main</code>, if no commit messages are found that meet the convention then the patch number is incremented by default.</p> <p>Here are some example commit messages which will result in a version increment:</p> Commit Message Type Example fix: Fixed a bug. Patch 1.1.10 -&gt; 1.1.11 feat: Added a feature. Minor 1.1.10 -&gt; 1.2.0 feat: Changed a feature. BREAKING CHANGE: This change breaks things. Major 1.1.10 -&gt; 2.0.0"},{"location":"pipelines/","title":"Pipelines","text":""},{"location":"pipelines/#ci-pipeline","title":"CI Pipeline","text":"<p>The CI pipeline builds and verifies the solution and runs a number of static code analysis steps on the code base. Once successful, if the pipeline is running against the <code>main</code> branch a GitHub release will be published using Semantic Release.</p> <p>Part of the build verification is end to end testing which requires the pipeline to login to an Azure tenant and deploy an environment on which to execute the tests.</p>"},{"location":"pipelines/#static-code-analysis","title":"Static Code Analysis","text":"<p>The following static code analysis checks are executed:</p> <ul> <li>Terraform format</li> <li>Terraform lint</li> <li>Checkov scan</li> <li>Gitleaks scan</li> <li>Trivy vulnerability scan</li> </ul>"},{"location":"pipelines/#pipeline-secrets","title":"Pipeline Secrets","text":"<p>In order for the pipeline to login to Azure the following secrets must be created:</p> <ul> <li><code>AZURE_TENANT_ID</code></li> </ul> <p>The ID of an Azure tenant which can be used for the end to end test environment.</p> <ul> <li><code>AZURE_SUBSCRIPTION_ID</code></li> </ul> <p>The ID of an Azure subscription which can be used for the end to end test environment.</p> <ul> <li><code>AZURE_CLIENT_ID</code></li> </ul> <p>The client ID of an Azure service principal / app registration which can be used to authenticate with the end to end test environment.</p> <p>The app registration must have contributor permissions on the subscription in order to create resources, and RBAC admin as described in Environment Setup.</p> <ul> <li><code>AZURE_CLIENT_SECRET</code></li> </ul> <p>The client secret of an Azure app registration which can be used to authenticate with the end to end test environment.</p> <ul> <li><code>TF_STATE_RESOURCE_GROUP</code></li> </ul> <p>The resource group which contains the TF state storage account.</p> <ul> <li><code>TF_STATE_STORAGE_ACCOUNT</code></li> </ul> <p>The storage account used for TF state.</p> <ul> <li><code>TF_STATE_STORAGE_CONTAINER</code></li> </ul> <p>The storage container used for TF state.</p> <p>For the release tag to be added to the repository the following secrets must be created:</p> <ul> <li><code>RELEASE_TOKEN</code></li> </ul> <p>A personal access token which allows the pipeline to commit a release tag to the repository. The PAT will expire periodically and must be maintained.</p> <p>The PAT should be a fine grained access token, restricted to the <code>az-backup</code> repository, with Read/Write for the \"Contents\" permission.</p>"},{"location":"security-guide/","title":"Security Guide","text":""},{"location":"security-guide/#security","title":"Security","text":""},{"location":"security-guide/#overview","title":"Overview","text":"<p>The security of the solution relies on configuration at the tenant and subscription level which is outside of the control of this module.</p> <p>The design proposed in this section acts as a best practice guide and it will be down to teams and programmes to implement the necessary controls and procedures.</p>"},{"location":"security-guide/#design","title":"Design","text":"<p>The following diagram illustrates the security design of the solution:</p> <p></p> <p>See the following links for further details on some concepts relevant to the design:</p> <ul> <li>Azure Multi-user Authorisation (MUA) and Resource Guard</li> <li>Backup Operator Role</li> <li>Azure Privileged Identity Management (PIM)</li> </ul>"},{"location":"security-guide/#actors","title":"Actors","text":"<p>NOTE: The roles listed below are not an exhaustive list, and are only those which are of relevance to the backup solution.</p>"},{"location":"security-guide/#1-tenant-admin","title":"1. Tenant Admin","text":"<p>The tenant admin, aka the \"global administrator\", is typically a restricted group of technical specialists and/or senior engineering staff. They have full control over the Azure tenant including all subscriptions and identities.</p> <p>The actor holds the following roles:</p> <ul> <li>Tenant Owner</li> <li>Tenant RBAC Administrator</li> </ul> <p>The following risks and mitigations should be considered:</p> Risks Mitigations Backup instance tampered with. Use of PIM for temporary elevated privileges. Backup policy tampered with. Use of MUA for restricted backup operations. Role based access tampered. Dedicated admin accounts. No other account able to override a malicious actor."},{"location":"security-guide/#2-subscription-admin","title":"2. Subscription Admin","text":"<p>The subscription admin is typically a restricted group of team leads who are deploying their teams solutions to the subscription. They have full control over the subscription, including the backup vault and the backup resources.</p> <p>The actor holds the following roles:</p> <ul> <li>Subscription Owner</li> <li>Subscription RBAC Administrator</li> </ul> <p>The following risks and mitigations should be considered:</p> Risks Mitigations Backup instance tampered with.\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Use of PIM for temporary elevated privileges. Backup policy tampered with. Use of MUA for restricted backup operations. Role based access tampered."},{"location":"security-guide/#3-deployment-service-principal","title":"3. Deployment Service Principal","text":"<p>The deployment service principal is an unattended credential used to deploy the solution from an automated process such as a pipeline or workflow. It has the permission to deploy resources (such as the backup vault) and assign the roles required for the solution to operate.</p> <p>The actor holds the following roles:</p> <ul> <li>Subscription Contributor</li> <li>Subscription RBAC Administrator limited to the roles required by the deployment  </li> </ul> <p>The following risks and mitigations should be considered:</p> Risks Mitigations Backup instance tampered with.\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Use of PIM for temporary elevated privileges. Backup policy tampered with. Use of MUA for restricted backup operations. Role based access tampered. Secret scanning in pipeline. Poor secret management. Robust secret management procedures."},{"location":"security-guide/#4-backup-admin","title":"4. Backup Admin","text":"<p>The backup admin is typically a group of team support engineers and/or technical specialists. They have the permission to monitor backup telemetry, and restore backups in order to recover services.</p> <p>The actor holds the following roles:</p> <ul> <li>Subscription Backup Operator</li> </ul>"},{"location":"security-guide/#5-backup-monitor","title":"5. Backup Monitor","text":"<p>The backup monitor is typically a group of service staff. They have the permission to monitor backup telemetry in order to raise the alarm if any issues are found.</p> <p>The actor holds the following roles:</p> <ul> <li>Monitoring Reader</li> </ul>"},{"location":"security-guide/#6-security-admin","title":"6. Security Admin","text":"<p>The security admin is typically a group of cyber security specialists that are isolated from the other actors, by being in a different tenant or a highly restricted subscription. They have permissions to manage Resource Guard, which provide multi user authorisation to perform restricted operations on the backup vault, such as changing policies or stopping a backup instance.</p> <p>The actor holds the following roles:</p> <ul> <li>Subscription Backup MUA Administrator</li> </ul> Risks Mitigations Elevated roles note revoked.\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Use of PIM for temporary elevated privileges. Robust and well documented processes. <p>NOTE: MUA without PIM requires a manual revocation of elevated permissions.</p>"},{"location":"security-guide/#7-backup-vault-managed-identity","title":"7. Backup Vault Managed Identity","text":"<p>The backup vault managed identity is a \"System Assigned\" managed identity that performs backup vault operations. It is restricted to just the services defined at deployment, and cannot be compromised at runtime.</p> <p>The actor holds the following roles:</p> <ul> <li>Backup Vault Resource Writer</li> <li>Reader role on resources that require backup</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#overview","title":"Overview","text":"<p>To use the az-backup terraform module, create a terraform module in your own code and set the source as the az-backup repository.</p> <p>See the following link for more information about using github as the source of a terraform module.</p> <p>The az-backup module resides in the <code>./infrastructure</code> sub directory of the repository, so you need to specify that in the module source by using the double-slash syntax as explained in this guide.</p> <p>By default, the module will create a dedicated resource group to contain the backup vault, therefore the resource group name provided to the module must be unique within the scope of the subscription. The creation of a dedicated resource group can be overridden if the vault needs to be deployed into an externally managed resource group.</p>"},{"location":"usage/#immutability","title":"Immutability","text":"<p>Immutability is configured by setting the <code>backup_vault_immutability</code> variable. The variable can be set as <code>Disabled</code> (default), <code>Unlocked</code> and <code>Locked</code>.</p> <p>IMPORTANT: A backup vault cannot be created in a <code>Locked</code> state, therefore you must first deploy it as <code>Unlocked</code>, and the update the configuration to <code>Locked</code> as a second step.</p>"},{"location":"usage/#retention","title":"Retention","text":"<p>By default the module restricts backup retention to 7 days, in order to protect against immutable copies of data being created which cannot be deleted.</p> <p>To override the restriction set the <code>use_extended_retention</code> variable to true, which will allow you to set a retention of any length.</p>"},{"location":"usage/#identity","title":"Identity","text":"<p>To deploy the module an Azure identity (e.g. an app registration with client secret) is required which has been assigned the following roles at the subscription level:</p> <ul> <li>Contributor (to create resources)</li> <li>Role Based Access Control Administrator (to assign roles to the backup vault managed identity) with a condition limiting the roles that can be assigned to:<ul> <li>Disk Backup Reader</li> <li>Disk Snapshot Contributor</li> <li>PostgreSQL Flexible Server Long Term Retention Backup Role</li> <li>Storage Account Backup Contributor</li> <li>Reader</li> </ul> </li> </ul>"},{"location":"usage/#deployment","title":"Deployment","text":"<p>Configure the tenant, subscription and credentials of the identity as environment variables and deploy with terraform.</p> <pre><code>$env:ARM_TENANT_ID=\"&lt;your-tenant-id&gt;\"\n$env:ARM_SUBSCRIPTION_ID=\"&lt;your-subscription-id&gt;\"\n$env:ARM_CLIENT_ID=\"&lt;your-client-id&gt;\"\n$env:ARM_CLIENT_SECRET=\"&lt;your-client-secret&gt;\"\n</code></pre>"},{"location":"usage/#example","title":"Example","text":"<p>The following is an example of how the module should be used - update the ref with the release version that you want to use:</p> <pre><code>module \"my_backup\" {\n  source                     = \"github.com/nhsdigital/az-backup//infrastructure?ref=&lt;version-number&gt;\"\n  resource_group_name        = \"rg-mybackup\"\n  resource_group_location    = \"uksouth\"\n  create_resource_group      = true\n  backup_vault_name          = \"bvault-mybackup\"\n  backup_vault_redundancy    = \"LocallyRedundant\"\n  backup_vault_immutability  = \"Unlocked\"\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.my_workspace.id\n  use_extended_retention     = true\n\n  tags = {\n    tagOne   = \"tagOneValue\"\n    tagTwo   = \"tagTwoValue\"\n    tagThree = \"tagThreeValue\"\n  }\n\n  blob_storage_backups = {\n    backup1 = {\n      backup_name                = \"storage1\"\n      retention_period           = \"P7D\"\n      backup_intervals           = [\"R/2024-01-01T00:00:00+00:00/P1D\"]\n      storage_account_id         = azurerm_storage_account.my_storage_account_1.id\n      storage_account_containers = [\"container1\", \"container2\"]\n    }\n    backup2 = {\n      backup_name                = \"storage2\"\n      retention_period           = \"P30D\"\n      backup_intervals           = [\"R/2024-01-01T00:00:00+00:00/P2D\"]\n      storage_account_id         = azurerm_storage_account.my_storage_account_2.id\n      storage_account_containers = [\"container1\", \"container2\"]\n    }\n  }\n  managed_disk_backups = {\n    backup1 = {\n      backup_name      = \"disk1\"\n      retention_period = \"P7D\"\n      backup_intervals = [\"R/2024-01-01T00:00:00+00:00/P1D\"]\n      managed_disk_id  = azurerm_managed_disk.my_managed_disk_1.id\n      managed_disk_resource_group = {\n        id   = azurerm_resource_group.my_resource_group.id\n        name = azurerm_resource_group.my_resource_group.name\n      }\n    }\n    backup2 = {\n      backup_name      = \"disk2\"\n      retention_period = \"P30D\"\n      backup_intervals = [\"R/2024-01-01T00:00:00+00:00/P2D\"]\n      managed_disk_id  = azurerm_managed_disk.my_managed_disk_2.id\n      managed_disk_resource_group = {\n        id   = azurerm_resource_group.my_resource_group.id\n        name = azurerm_resource_group.my_resource_group.name\n      }\n    }\n  }\n  postgresql_flexible_server_backups = {\n    backup1 = {\n      backup_name      = \"server1\"\n      retention_period = \"P7D\"\n      backup_intervals = [\"R/2024-01-01T00:00:00+00:00/P1D\"]\n      server_id  = azurerm_postgresql_flexible_server.my_server_1.id\n      server_resource_group_id = azurerm_resource_group.my_resource_group.id\n    }\n    backup2 = {\n      backup_name      = \"server2\"\n      retention_period = \"P30D\"\n      backup_intervals = [\"R/2024-01-01T00:00:00+00:00/P2D\"]\n      server_id  = azurerm_postgresql_flexible_server.my_server_2.id\n      server_resource_group_id = azurerm_resource_group.my_resource_group.id\n    }\n  }\n}\n</code></pre>"},{"location":"usage/#input-variables","title":"Input Variables","text":"Name Description Required Default <code>resource_group_name</code> The name of the resource group that is created to contain the vault - the resource group will be created if <code>create_resource_group</code> = true, and must be an existing resource group if <code>create_resource_group</code> = false. Yes n/a <code>resource_group_location</code> The location of the resource group. No <code>uksouth</code> <code>create_resource_group</code> States whether a resource group should be created. Setting this to <code>false</code> means the vault will be deployed into an externally managed resource group, the name of which is defined in <code>resource_group_name</code>. No <code>true</code> <code>backup_vault_name</code> The name of the backup vault. The value supplied will be automatically prefixed with <code>rg-nhsbackup-</code>. If more than one az-backup module is created, this value must be unique across them. Yes n/a <code>backup_vault_redundancy</code> The redundancy of the vault, e.g. <code>GeoRedundant</code>. See the following link for the possible values. No <code>LocallyRedundant</code> <code>backup_vault_immutability</code> The immutability of the vault, e.g. <code>Locked</code>. See the following link for the possible values. No <code>Disabled</code> <code>log_analytics_workspace_id</code> The id of the log analytics workspace that backup telemetry and diagnostics should be sent to. NOTE this variable was made mandatory in v2 of the module. Yes n/a <code>tags</code> A map of tags which will be applied to the resource group and backup vault. When no tags are specified then no tags are added. NOTE when using an externally managed resource group the tags will not be applied to it (they will still be applied to the backup vault). No n/a <code>use_extended_retention</code> If set to true, then the backup retention periods can be set to anything, otherwise they are limited to 7 days. No <code>false</code> <code>blob_storage_backups</code> A map of blob storage backups that should be created. For each backup the following values should be provided: <code>storage_account_id</code>, <code>backup_name</code> and <code>retention_period</code>. When no value is provided then no backups are created. No n/a <code>blob_storage_backups.storage_account_id</code> The id of the storage account that should be backed up. Yes n/a <code>blob_storage_backups.storage_account_containers</code> A list of containers in the storage account that should be backed up. Yes n/a <code>blob_storage_backups.backup_name</code> The name of the backup, which must be unique across blob storage backups. Yes n/a <code>blob_storage_backups.retention_period</code> How long the backed up data will be retained for, which should be in <code>ISO 8601</code> duration format. This must be specified in days, and can be up to 7 days unless <code>use_extended_retention</code> is on. See the following link for more information about the format. Yes n/a <code>blob_storage_backups.backup_intervals</code> A list of intervals at which backups should be taken, which should be in <code>ISO 8601</code> duration format. See the following link for the possible values. Yes n/a <code>managed_disk_backups</code> A map of managed disk backups that should be created. For each backup the following values should be provided: <code>managed_disk_id</code>, <code>backup_name</code> and <code>retention_period</code>. When no value is provided then no backups are created. No n/a <code>managed_disk_backups.managed_disk_id</code> The id of the managed disk that should be backed up. Yes n/a <code>managed_disk_backups.backup_name</code> The name of the backup, which must be unique across managed disk backups. Yes n/a <code>managed_disk_backups.retention_period</code> How long the backed up data will be retained for, which should be in <code>ISO 8601</code> duration format. This must be specified in days, and can be up to 7 days unless <code>use_extended_retention</code> is on. See the following link for more information about the format. Yes n/a <code>managed_disk_backups.backup_intervals</code> A list of intervals at which backups should be taken, which should be in <code>ISO 8601</code> duration format. See the following link for the possible values. Yes n/a <code>postgresql_flexible_server_backups</code> A map of postgresql flexible server backups that should be created. For each backup the following values should be provided: <code>backup_name</code>, <code>server_id</code>, <code>server_resource_group_id</code>, <code>retention_period</code> and <code>backup_intervals</code>. When no value is provided then no backups are created. No n/a <code>postgresql_flexible_server_backups.backup_name</code> The name of the backup, which must be unique across postgresql flexible server backups. Yes n/a <code>postgresql_flexible_server_backups.server_id</code> The id of the postgresql flexible server that should be backed up. Yes n/a <code>postgresql_flexible_server_backups.server_resource_group_id</code> The id of the resource group which the postgresql flexible server resides in. Yes n/a <code>postgresql_flexible_server_backups.retention_period</code> How long the backed up data will be retained for, which should be in <code>ISO 8601</code> duration format. This must be specified in days, and can be up to 7 days unless <code>use_extended_retention</code> is on. See the following link for more information about the format. Yes n/a <code>postgresql_flexible_server_backups.backup_intervals</code> A list of intervals at which backups should be taken, which should be in <code>ISO 8601</code> duration format. See the following link for the possible values. Yes n/a"}]}